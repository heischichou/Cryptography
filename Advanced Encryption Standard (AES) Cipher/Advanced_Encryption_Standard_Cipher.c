#define aesCipher
#ifndef aesCipher  

#include "../common.c"

/*
 * Advanced Encryption Standard (AES) Cipher program by
 * @author Jan Michael Garot/Heischichou (https://github.com/heischichou)
*/

// Constants for 128-bit AES
#define SIZE 4
#define AES_NROUNDS 10

// type declarations
typedef unsigned char Matrix[SIZE][SIZE];

// substitution box lookup matrices
static const unsigned char aes_sbox[16][16] = {
	// 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
	{0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76}, // 0
	{0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0}, // 1
	{0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15}, // 2
	{0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75}, // 3
	{0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84}, // 4
	{0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF}, // 5
	{0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8}, // 6
	{0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2}, // 7
	{0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73}, // 8
	{0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB}, // 9
	{0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79}, // A
	{0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08}, // B
	{0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A}, // C
	{0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E}, // D
	{0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF}, // E
	{0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16}  // F
};
	
static const unsigned char aes_sbox_inv[16][16] = {
	// 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
	{0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB}, // 0
	{0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB}, // 1
	{0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E}, // 2
	{0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25}, // 3
	{0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92}, // 4
	{0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84}, // 5
	{0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06}, // 6
	{0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B}, // 7
	{0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73}, // 8
	{0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E}, // 9
	{0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B}, // A
	{0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4}, // B
	{0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F}, // C
	{0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF}, // D
	{0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61}, // E
	{0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D}  // F
};

// mix columns constant matrix
static const Matrix aes_constant = {
	{0x02, 0x03, 0x01, 0x01},
	{0x01, 0x02, 0x03, 0x01},
	{0x01, 0x01, 0x02, 0x03},
	{0x03, 0x01, 0x01, 0x02}
};

static const Matrix aes_constant_inv = {
	{0x0E, 0x0B, 0x0D, 0x09},
	{0x09, 0x0E, 0x0B, 0x0D},
	{0x0D, 0x09, 0x0E, 0x0B},
	{0x0B, 0x0D, 0x09, 0x0E}
};

// AES Key Expansion Round Constants
static const unsigned char rcon[256] = {
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
};

// helper functions
void populate_matrix(Matrix M, char *text){
	int x, y, z;
	
	for(y = 0, z = 0; y < SIZE && z < 16; y++){
		for(x = 0; x < SIZE; x++){
			M[x][y] = text[z++];
		}
	}
}

void print_matrix_char(Matrix M){
	int x, y;

	for(x = 0; x < SIZE; x++){
		for(y = 0; y < SIZE; y++){
			printf("%-3c ", M[x][y]);
		}
		
		printf("\n");
	}
	
	printf("\n");
}

void print_matrix_hex(Matrix M){
	int x, y;

	for(x = 0; x < SIZE; x++){
		for(y = 0; y < SIZE; y++){
			printf("%-3x ", M[x][y]);
		}
		
		printf("\n");
	}
	
	printf("\n");
}

// Galois Field Multiplication
unsigned char gmult(unsigned char aes_constant, unsigned char state_value){
	unsigned char x = state_value;
	
	if(aes_constant > 1){
		x <<= 1;
		if(aes_constant == 3){
			x^= 0x02;
			x^= state_value;
		} else {
			x^= aes_constant;
		}
		
		if((state_value & 0x80) == 128){
			x^= 0x1B;
		}
	}
    
	return x;
}

// Substitute Bytes
void sub_bytes(Matrix state){
	int x, y;
	unsigned char row, col;
	
	for(y = 0; y < SIZE; y++){
		for(x = 0; x < SIZE; x++){
			row = (0xF0 & state[x][y]) >> 4; // extract leftmost 4 bits
			col = 0x0F & state[x][y];        // extract rightmost 4 bits
			
			state[x][y] = aes_sbox[row][col];
		}
	}
}

// Shift Rows
void shift_rows(Matrix state){
	unsigned char temp;
	
	// Shift first row by 1 column to the left
	temp = state[1][0];
	state[1][0] = state[1][1];
	state[1][1] = state[1][2];
	state[1][2] = state[1][3];
	state[1][3] = temp;
	
	// Shift second row by 2 columns to the left
	temp = state[2][0];
	state[2][0] = state[2][2];
	state[2][2] = temp;

	temp = state[2][1];
	state[2][1] = state[2][3];
	state[2][3] = temp;
	
	// Shift third row by 3 column to the left
	temp = state[3][0];
	state[3][0] = state[3][3];
	state[3][3] = state[3][2];
	state[3][2] = state[3][1];
	state[3][1] = temp;
}

void shift_rows_inv(Matrix state){
	unsigned char temp;
	
	// Shift first row by 1 column to the right
	temp = state[3][1];
	state[3][1] = state[2][1];
	state[2][1] = state[1][1];
	state[1][1] = state[0][1];
	state[0][1] = temp;
	
	// Shift second row by 2 columns to the right
	temp = state[0][2];
	state[0][2] = state[2][2];
	state[2][2] = temp;
	
	temp = state[1][2];
	state[1][2] = state[3][2];
	state[3][2] = temp;
	
	// Shift third row by 3 column to the right
	temp = state[0][3];
	state[0][3] = state[1][3];
	state[1][3] = state[2][3];
	state[2][3] = state[3][3];
	state[3][3] = temp;
}

// Expand the current round key
void expand_key(Matrix key, Matrix expanded_key, int round){
	int x, y;
	unsigned char temp, row, col;
	
	// Copy into First Word
	for(x = 0; x < SIZE; x++){
        expanded_key[x][0] = key[x][SIZE - 1];
    }
	
	// Rotate First Word
	temp = expanded_key[0][0];
    for(x = 0; x < SIZE - 1 ; x++){
        expanded_key[x][0] = expanded_key[x + 1][0];
    }
    expanded_key[SIZE - 1][0] = temp;
    
    // Substitution Bytes
	for(x = 0; x < SIZE; x++){
		row = (0xF0 & expanded_key[x][0]) >> 4; // extract leftmost 4 bits
		col = 0x0F & expanded_key[x][0];        // extract rightmost 4 bits
		
		expanded_key[x][0] = aes_sbox[row][col];
	}
	
	expanded_key[0][0] ^= rcon[round];
	
	// XOR First Word
	for(x = 0; x < SIZE; x++){	
		expanded_key[x][0] ^= key[x][0];
	}
	
	// W(0) XOR W(n)
	for(y = 1; y < SIZE; y++){
		for(x = 0; x < SIZE; x++){
			expanded_key[x][y] = (expanded_key[x][y - 1] ^ key[x][y]);
		}
	}
}

// MixColumns
void mix_columns(Matrix state, Matrix mixed_cols){
	int x, y;
	
	for(x = 0; x < SIZE; x++){
		for(y = 0; y < SIZE; y++){	
			mixed_cols[y][x] = (unsigned char) (
				(gmult(aes_constant[y][0], state[0][x])) ^
				(gmult(aes_constant[y][1], state[1][x])) ^
				(gmult(aes_constant[y][2], state[2][x])) ^
				(gmult(aes_constant[y][3], state[3][x]))
			);
		}
	}
}

// AES Encrypt and Decrypt
char* encrypt(Matrix message, Matrix key, char *encrypted_key){
	int x, y, length = (SIZE * SIZE) + 1, round;
	char *encrypted_text = (char*) calloc(1, length * sizeof(unsigned char));
	Matrix state, 
		round_key, 
		mixed_cols = {'\0'},
		expanded_key = {'\0'};
		
	memcpy(state, message, sizeof(Matrix));
	memcpy(round_key, key, sizeof(Matrix));
	
	// Add Round Key		
	for(y = 0; y < SIZE; y++){
		for(x = 0; x < SIZE; x++){
			state[x][y] = (state[x][y]) ^ (round_key[x][y]);
		}
	}
	
	for(round = 1; round <= AES_NROUNDS; round++){
		// Substitute Bytes
		sub_bytes(state);
		
		// Shift Rows
		shift_rows(state);
		
		// MixColumns
		if(round < AES_NROUNDS){
			mix_columns(state, mixed_cols);
			memcpy(state, mixed_cols, sizeof(Matrix));
		}
		
		// Expand Round Key
		expand_key(round_key, expanded_key, round);
		memcpy(round_key, expanded_key, sizeof(Matrix));
		
		// Add Round Key		
		for(y = 0; y < SIZE; y++){
			for(x = 0; x < SIZE; x++){
				state[x][y] = (state[x][y]) ^ (round_key[x][y]);
			}
		}
	}
	
	print_matrix_hex(state);
	
	// Write ciphertext
	for(y = 0, round = 0; y < SIZE && round < length; y++){
		for(x = 0; x < SIZE; x++){
			encrypted_text[round++] = (char) 0xFF & state[x][y];  
		}
	}

	// Write encrypted_key
	for(y = 0, round = 0; y < SIZE && round < length; y++){
		for(x = 0; x < SIZE; x++){
			encrypted_key[round++] = (char) 0xFF & round_key[x][y];  
		}
	}
	
	return encrypted_text;
}

#endif